Ex 1.

A.
1)
touch test1 test2.c testt44.pdf test455 testt41.c test510.c test_all.pdf testmaker

2)
mkdir Exercice1
mv test* Exercice1

3)
ls *5
ls testt*
ls *.pdf
ls t???t*

B.
1)
ls | grep -v "testmaker"
ls | grep -n "455"
ls | grep "\.c"

Ex 2.

who > fich
cat fich
date > fich
> : Créer un fichier si il n'existe pas et ajout le résultat de la commande ou écrase le contenu si il existe déjà
who >> fich
>> : Ajoute à la fin du fichier existant sans l'écraser le résultat de la commande



Ex 3.

A)
Ctrl-C tue le processus en cours alors que Ctrl-D arrête normalement le processus en signalant EOF.
cat < fich redirige tout ce qui est entré après le < vers la commande cat.

B)
wc fich
cat fich | wc

Ex 4.

A)
1.
dater > erreur
Le fichier est crée mais vide, l'erreur est affiché dans le terminal.

2.
dater 2> erreur

B)
1.
ls -R /home 2> /dev/null

Ex 5.

A) 
O_WRONLY | O_EXCL | O_CREAT
On utilise les options suivantes car on veut créer un nouveau fichier sans le lire et on veut pouvoir gérer le cas où le fichier existe déjà en affichant un message d'erreur

B)
Le fichier est déjà crée donc le open échoue et affiche l'erreur:
open: File exists

Ex 6.

B) 
Le programme créer un buffer de 20 caractères afin de contenir ce qu'il y a dans le fichier test1.txt
Il essaye d'ouvrir en lecture seule le fichier.
Si l'ouverture échoue, il affiche une erreur et quitte le programme.
Si elle réussit, il essaye de lire dans le fichier maximum 100 charactères et les mets dans le buffer qui peut en contenir que 20.
Il affiche le nombre de caractères lus et les charactères lus puis ferme le fichier.

C)
Il affiche un message d'erreur:
open for write: failed

D)
Il n'en lit que 20 même si il y en a plus dans le fichier

E)
screenshots à prendre

Ex 7.

G)
screenshots à prendre

Ex 8.

B)
Oui sinon il y aurait eu un message d'erreur lors de la création.
Le contenu du fichier 1 est copié dans le fichier 2 puisqu'on lit le contenu du fichier tant que le nombre de bytes retourné par celui ci est supérieur à 0. Le contenu de chaque byte lu est copié dans le fichier 2.

C)
open(argv[2], O_WRONLY | O_CREAT | O_APPEND, S_IRWXU);
Le premier arg correspond au nom du fichier à créer pour la copie.
Le deuxième correspond à écriture seule, avec création de fichier et ajout des données à la fin du fichier.
Le troisième correspond aux permissions du fichier à crée, ici 700-rwx pour l'owner.
Si on essaye avec un fichier qui existe déjà, le contenu de f1 est rajouté au fichier existant.

Ex 9.

D)
screenshots à prendre
